import { useMemo, useRef } from 'react'
import * as THREE from 'three'
import { useFrame, useThree } from '@react-three/fiber'

/* ─────────────────── seeded PRNG ─────────────────── */
function mulberry32(seed) {
  return () => {
    seed |= 0; seed = (seed + 0x6d2b79f5) | 0
    let t = Math.imul(seed ^ (seed >>> 15), 1 | seed)
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296
  }
}

/* ─── helper: deform geometry vertices for organic feel ─── */
function deformGeo(geo, rng, amount = 0.04) {
  const pos = geo.attributes.position
  for (let i = 0; i < pos.count; i++) {
    pos.setX(i, pos.getX(i) + (rng() - 0.5) * amount)
    pos.setY(i, pos.getY(i) + (rng() - 0.5) * amount)
    pos.setZ(i, pos.getZ(i) + (rng() - 0.5) * amount)
  }
  pos.needsUpdate = true
  geo.computeVertexNormals()
  return geo
}

/* ════════════════════════════════════════════════════════════
   1. CHIPPI — Oyster Shell
   Two curved half-shells with optional pearl inside.
   ════════════════════════════════════════════════════════════ */

/**
 * Build a single curved shell half using LatheGeometry.
 * Profile: thin at lip, thick at hinge — like a real bivalve cross-section.
 */
function makeShellGeo(rng) {
  const pts = []
  const segments = 10
  for (let i = 0; i <= segments; i++) {
    const t = i / segments
    // Shell profile: radius grows from hinge (t=0) to lip (t=1)
    // with organic waviness
    const r = 0.02 + t * 0.22 + Math.sin(t * Math.PI) * 0.06
    const y = t * 0.04 + Math.sin(t * Math.PI * 0.8) * 0.03
    pts.push(new THREE.Vector2(r + (rng() - 0.5) * 0.015, y))
  }
  const geo = new THREE.LatheGeometry(pts, 14, 0, Math.PI * 2)
  return deformGeo(geo, rng, 0.008)
}

function Chippi({ position, scale, rng, hasPearl }) {
  const rotY = rng() * Math.PI * 2
  // Open angle: 0 = closed, larger = more open
  // Most shells barely open, a few slightly agape
  const openAngle = rng() < 0.3 ? 0.08 + rng() * 0.15 : 0.02 + rng() * 0.06

  const topGeo = useMemo(() => makeShellGeo(rng), [])
  const botGeo = useMemo(() => makeShellGeo(rng), [])

  // Outer shell: weathered grey-brown
  const outerCol = useMemo(() => {
    const r = 0.32 + rng() * 0.08
    const g = 0.3 + rng() * 0.06
    const b = 0.26 + rng() * 0.05
    return new THREE.Color(r, g, b)
  }, [])

  // Inner shell: pearlescent cream
  const innerCol = new THREE.Color(0.75, 0.72, 0.68)

  return (
    <group position={position} scale={scale} rotation={[0, rotY, 0]}>
      {/* Bottom shell — sits on sand */}
      <mesh geometry={botGeo} rotation={[Math.PI, 0, 0]} position={[0, 0.01, 0]}
        receiveShadow castShadow>
        <meshStandardMaterial color={outerCol} roughness={0.92} metalness={0.02} flatShading />
      </mesh>

      {/* Top shell — hinged open */}
      <group position={[0.18, 0.015, 0]} rotation={[0, 0, openAngle]}>
        <mesh geometry={topGeo} position={[-0.18, 0, 0]} castShadow receiveShadow>
          <meshStandardMaterial color={outerCol} roughness={0.92} metalness={0.02} flatShading />
        </mesh>
      </group>

      {/* Inner nacre lining — visible through the gap */}
      <mesh position={[0, 0.015, 0]} rotation={[Math.PI / 2, 0, 0]}>
        <circleGeometry args={[0.12, 10]} />
        <meshStandardMaterial
          color={innerCol} roughness={0.3} metalness={0.25}
          side={THREE.BackSide} flatShading
        />
      </mesh>

      {/* Pearl — only 20% have one */}
      {hasPearl && (
        <mesh position={[rng() * 0.04 - 0.02, 0.025, rng() * 0.04 - 0.02]}>
          <sphereGeometry args={[0.018, 8, 6]} />
          <meshStandardMaterial
            color="#e8e4e0" roughness={0.15} metalness={0.4}
            emissive="#8ab4c8" emissiveIntensity={0.06}
          />
        </mesh>
      )}

      {/* Sand embedding — small bumps at base */}
      <mesh position={[0, -0.005, 0]} rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <circleGeometry args={[0.16, 8]} />
        <meshStandardMaterial color="#8a7555" roughness={1} metalness={0} transparent opacity={0.5} />
      </mesh>
    </group>
  )
}


/* ════════════════════════════════════════════════════════════
   2. SANGU — Conch Shell (Spiral LatheGeometry)
   ════════════════════════════════════════════════════════════ */

/**
 * Build a conch shell using a spiral path + LatheGeometry.
 * The spiral is generated by rotating a profile along a helical path.
 * We use a custom TubeGeometry with a fibonacci-spiral curve.
 */
function makeSanguGeo(rng) {
  // Build a 3D spiral curve
  const spiralPts = []
  const turns = 2.5 + rng() * 0.5
  const segments = 60
  for (let i = 0; i <= segments; i++) {
    const t = i / segments
    const angle = t * turns * Math.PI * 2
    // Spiral tightens — radius decreases as we go up
    const radius = 0.2 * (1 - t * 0.85) + 0.02
    // Height increases with taper
    const y = t * 0.45
    const x = Math.cos(angle) * radius
    const z = Math.sin(angle) * radius
    spiralPts.push(new THREE.Vector3(x, y, z))
  }

  const curve = new THREE.CatmullRomCurve3(spiralPts)

  // Tube radius tapers along the spiral — wide at mouth, narrow at tip
  const radiusFunc = (t) => {
    const base = 0.06 * (1 - t * 0.88) + 0.005
    return base
  }

  // Build using TubeGeometry with varying radius
  // We'll use a custom approach: sample the curve, build tube manually
  const tubularSegments = 40
  const radialSegments = 8
  const geo = new THREE.TubeGeometry(curve, tubularSegments, 0.04, radialSegments, false)

  // Manually taper the radius
  const pos = geo.attributes.position
  const frames = curve.computeFrenetFrames(tubularSegments, false)

  for (let i = 0; i <= tubularSegments; i++) {
    const t = i / tubularSegments
    const scaleFactor = (1 - t * 0.88) + 0.12
    const center = curve.getPoint(t)

    for (let j = 0; j <= radialSegments; j++) {
      const idx = i * (radialSegments + 1) + j
      if (idx < pos.count) {
        const dx = pos.getX(idx) - center.x
        const dy = pos.getY(idx) - center.y
        const dz = pos.getZ(idx) - center.z

        pos.setX(idx, center.x + dx * scaleFactor)
        pos.setY(idx, center.y + dy * scaleFactor)
        pos.setZ(idx, center.z + dz * scaleFactor)
      }
    }
  }

  pos.needsUpdate = true
  geo.computeVertexNormals()
  return deformGeo(geo, rng, 0.005)
}

function Sangu({ position, scale, rng }) {
  const rotY = rng() * Math.PI * 2
  const tilt = (rng() - 0.5) * 0.3

  const shellGeo = useMemo(() => makeSanguGeo(rng), [])

  // Off-white with slight pink tint
  const shellColor = useMemo(() => {
    return new THREE.Color(
      0.72 + rng() * 0.06,
      0.66 + rng() * 0.05,
      0.62 + rng() * 0.04
    )
  }, [])

  const innerColor = new THREE.Color(0.68, 0.55, 0.55) // pink tint inside

  return (
    <group position={position} scale={scale} rotation={[tilt, rotY, (rng() - 0.5) * 0.15]}>
      {/* Main shell body */}
      <mesh geometry={shellGeo} castShadow receiveShadow>
        <meshStandardMaterial
          color={shellColor}
          roughness={0.75}
          metalness={0.05}
          flatShading
        />
      </mesh>

      {/* Inner lip — slight pink tone visible at the opening */}
      <mesh position={[0.16, 0.02, 0]} rotation={[0, 0, Math.PI / 6]}>
        <circleGeometry args={[0.06, 8]} />
        <meshStandardMaterial
          color={innerColor}
          roughness={0.4}
          metalness={0.1}
          side={THREE.DoubleSide}
        />
      </mesh>

      {/* Sand embedding */}
      <mesh position={[0, -0.01, 0]} rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <circleGeometry args={[0.14, 8]} />
        <meshStandardMaterial color="#8a7555" roughness={1} metalness={0} transparent opacity={0.4} />
      </mesh>
    </group>
  )
}


/* ════════════════════════════════════════════════════════════
   3. BUSHY CORAL — Recursive branching
   ════════════════════════════════════════════════════════════ */

/**
 * Recursive branching structure — each branch splits into 2-3 sub-branches
 * with randomized angles. Limited to 3 levels for performance.
 */
function buildBranches(rng, depth, maxDepth, parentRadius) {
  if (depth > maxDepth) return []

  const branches = []
  const count = depth === 0 ? 3 + Math.floor(rng() * 2) : 2 + Math.floor(rng() * 2)

  for (let i = 0; i < count; i++) {
    const angle = (i / count) * Math.PI * 2 + (rng() - 0.5) * 1.2
    const lean = 0.2 + rng() * 0.6 + depth * 0.15
    const h = (0.25 + rng() * 0.3) * (1 - depth * 0.2)
    const radius = parentRadius * (0.5 + rng() * 0.3)
    const twist = (rng() - 0.5) * 0.5

    const children = buildBranches(rng, depth + 1, maxDepth, radius)

    branches.push({ angle, lean, h, radius, twist, children, yOffset: 0.6 + rng() * 0.3 })
  }
  return branches
}

function BranchMesh({ branch, color, accentColor, depth }) {
  return (
    <group rotation={[branch.lean, branch.angle, branch.twist]}>
      <mesh castShadow receiveShadow>
        <cylinderGeometry args={[branch.radius * 0.4, branch.radius, branch.h, 5, 1]} />
        <meshStandardMaterial
          color={depth % 2 === 0 ? color : accentColor}
          roughness={0.88}
          metalness={0.02}
          flatShading
        />
      </mesh>
      {branch.children.map((child, i) => (
        <group key={i} position={[0, branch.h * child.yOffset, 0]}>
          <BranchMesh branch={child} color={color} accentColor={accentColor} depth={depth + 1} />
        </group>
      ))}
      {/* Tiny tip bulbs on terminal branches */}
      {branch.children.length === 0 && (
        <mesh position={[0, branch.h * 0.45, 0]}>
          <sphereGeometry args={[branch.radius * 0.7, 4, 3]} />
          <meshStandardMaterial color={accentColor} roughness={0.85} metalness={0.02} flatShading />
        </mesh>
      )}
    </group>
  )
}

function BushyCoral({ position, scale, rng }) {
  const rotY = rng() * Math.PI * 2

  const branches = useMemo(() => {
    return buildBranches(rng, 0, 3, 0.04 + rng() * 0.02)
  }, [])

  // Deep muted purple + greenish algae tone
  const baseColor = useMemo(() => {
    const pick = rng()
    if (pick < 0.5) {
      // Deep muted purple
      return new THREE.Color(0.28 + rng() * 0.06, 0.18 + rng() * 0.04, 0.3 + rng() * 0.06)
    } else {
      // Greenish algae
      return new THREE.Color(0.18 + rng() * 0.06, 0.28 + rng() * 0.06, 0.2 + rng() * 0.04)
    }
  }, [])

  const accentColor = useMemo(() => {
    return new THREE.Color(
      baseColor.r * 1.2 + 0.04,
      baseColor.g * 1.15 + 0.03,
      baseColor.b * 1.1 + 0.03
    )
  }, [])

  return (
    <group position={position} scale={scale} rotation={[0, rotY, 0]}>
      {/* Rocky base */}
      <mesh position={[0, 0, 0]} receiveShadow>
        <dodecahedronGeometry args={[0.1, 0]} />
        <meshStandardMaterial color={baseColor} roughness={0.95} metalness={0.02} flatShading />
      </mesh>

      {/* Main trunk + recursive branches */}
      <group position={[0, 0.08, 0]}>
        {/* Central stem */}
        <mesh castShadow>
          <cylinderGeometry args={[0.025, 0.05, 0.3, 6, 1]} />
          <meshStandardMaterial color={baseColor} roughness={0.9} metalness={0.02} flatShading />
        </mesh>

        {/* Recursive branches */}
        {branches.map((br, i) => (
          <group key={i} position={[0, 0.12 + i * 0.04, 0]}>
            <BranchMesh branch={br} color={baseColor} accentColor={accentColor} depth={0} />
          </group>
        ))}
      </group>
    </group>
  )
}


/* ════════════════════════════════════════════════════════════
   4. PLATE CORAL — Stacked overlapping bent discs
   ════════════════════════════════════════════════════════════ */

function makePlateGeo(rng, radius) {
  // Create a circle, then deform for rough edges + slight bend
  const geo = new THREE.CircleGeometry(radius, 12 + Math.floor(rng() * 4))
  const pos = geo.attributes.position

  for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i)
    const y = pos.getY(i)
    // Rough edge: vary radius
    const dist = Math.sqrt(x * x + y * y)
    if (dist > radius * 0.5) {
      const noise = (rng() - 0.5) * radius * 0.2
      const angle = Math.atan2(y, x)
      pos.setX(i, Math.cos(angle) * (dist + noise))
      pos.setY(i, Math.sin(angle) * (dist + noise))
    }
    // Slight upward bend at edges (bowl shape)
    const bendFactor = dist / radius
    pos.setZ(i, bendFactor * bendFactor * radius * 0.15 * (0.8 + rng() * 0.4))
  }
  pos.needsUpdate = true
  geo.computeVertexNormals()
  return geo
}

function PlateCoral({ position, scale, rng }) {
  const rotY = rng() * Math.PI * 2
  const layerCount = 3 + Math.floor(rng() * 3) // 3–5 layers

  const layers = useMemo(() => {
    const l = []
    for (let i = 0; i < layerCount; i++) {
      const radius = 0.25 + rng() * 0.15 - i * 0.03
      l.push({
        geo: makePlateGeo(rng, radius),
        y: i * 0.06 + rng() * 0.02,
        rotX: (rng() - 0.5) * 0.2,  // slight tilt
        rotZ: (rng() - 0.5) * 0.15,
      })
    }
    return l
  }, [])

  // Muted brown-green — like real plate corals
  const color = useMemo(() => {
    return new THREE.Color(
      0.28 + rng() * 0.08,
      0.3 + rng() * 0.08,
      0.22 + rng() * 0.06
    )
  }, [])

  const edgeColor = useMemo(() => {
    return new THREE.Color(color.r * 0.85, color.g * 0.9, color.b * 0.8)
  }, [])

  return (
    <group position={position} scale={scale} rotation={[0, rotY, 0]}>
      {/* Rocky base */}
      <mesh position={[0, -0.02, 0]} receiveShadow>
        <dodecahedronGeometry args={[0.08, 0]} />
        <meshStandardMaterial color={edgeColor} roughness={0.95} metalness={0.02} flatShading />
      </mesh>

      {/* Stacked plate layers */}
      {layers.map((layer, i) => (
        <mesh
          key={i}
          geometry={layer.geo}
          position={[0, layer.y, 0]}
          rotation={[-Math.PI / 2 + layer.rotX, 0, layer.rotZ]}
          castShadow receiveShadow
        >
          <meshStandardMaterial
            color={i === layerCount - 1 ? color : edgeColor}
            roughness={0.88}
            metalness={0.02}
            side={THREE.DoubleSide}
            flatShading
          />
        </mesh>
      ))}
    </group>
  )
}


/* ════════════════════════════════════════════════════════════
   5. MUTHU — Pearl (rare, near camera only)
   ════════════════════════════════════════════════════════════ */

function Muthu({ position, scale, rng }) {
  const pearlRef = useRef()
  const { camera } = useThree()

  // Subtle pulsing glow
  useFrame((state) => {
    if (!pearlRef.current) return
    const t = state.clock.elapsedTime
    pearlRef.current.emissiveIntensity = 0.08 + Math.sin(t * 1.5 + rng() * 10) * 0.04
  })

  // Slight size variation
  const r = (0.02 + rng() * 0.015) * scale

  return (
    <mesh position={position} castShadow>
      <sphereGeometry args={[r, 12, 8]} />
      <meshStandardMaterial
        ref={pearlRef}
        color="#e2ddd8"
        roughness={0.12}
        metalness={0.5}
        emissive="#6a9db8"
        emissiveIntensity={0.08}
      />
    </mesh>
  )
}


/* ════════════════════════════════════════════════════════════
   PLACEMENT SYSTEM — Depth-based realistic ecosystem
   ════════════════════════════════════════════════════════════

   Camera path:  z = 0 → -62
   Foreground:   z = 5  to -8  (high detail, all types)
   Mid-ground:   z = -8 to -40 (silhouettes — fewer, smaller)
   Background:   z = -40 to -70 (shapes only — rare, tiny)

   Rules:
   - Less = realistic, More = game scene
   - Keep empty sand areas
   - Assets on BOTH sides, clear the centre path
   ════════════════════════════════════════════════════════════ */

const FLOOR_Y = -2
const CENTER_CLEAR = 8  // min |x| from centre to keep path clear

function generatePlacements() {
  const rng = mulberry32(77) // different seed from Corals
  const assets = []

  /* ─── FOREGROUND (z: 5 to -8) — Full detail, specific ecosystem ─── */

  // 1 Sangu (conch) — prominent, slightly off-path
  assets.push({
    type: 'sangu',
    x: (rng() > 0.5 ? 1 : -1) * (CENTER_CLEAR + 2 + rng() * 6),
    z: 2 + rng() * 4,
    scale: 1.8 + rng() * 0.8,
    seed: Math.floor(rng() * 99999),
  })

  // 2-3 Chippi (oyster shells) — near the conch, embedded in sand
  const chippiCount = 2 + Math.floor(rng() * 2)
  for (let i = 0; i < chippiCount; i++) {
    const side = rng() > 0.5 ? 1 : -1
    assets.push({
      type: 'chippi',
      x: side * (CENTER_CLEAR - 2 + rng() * 12),
      z: -2 + rng() * 8,
      scale: 1.4 + rng() * 0.8,
      seed: Math.floor(rng() * 99999),
      hasPearl: rng() < 0.2, // 20% chance
    })
  }

  // 1 Bushy coral — foreground cluster
  assets.push({
    type: 'bushy',
    x: (rng() > 0.5 ? 1 : -1) * (CENTER_CLEAR + 3 + rng() * 8),
    z: -3 + rng() * 6,
    scale: 1.6 + rng() * 0.8,
    seed: Math.floor(rng() * 99999),
  })

  // 1 Plate coral — foreground
  assets.push({
    type: 'plate',
    x: (rng() > 0.5 ? 1 : -1) * (CENTER_CLEAR + 1 + rng() * 10),
    z: -1 + rng() * 5,
    scale: 1.5 + rng() * 0.7,
    seed: Math.floor(rng() * 99999),
  })

  // 1-2 Pearls — rare, near camera path, on the sand
  const pearlCount = 1 + Math.floor(rng() * 2)
  for (let i = 0; i < pearlCount; i++) {
    assets.push({
      type: 'muthu',
      x: (rng() - 0.5) * 6, // close to centre — camera will pass near
      z: 1 + rng() * 5,
      scale: 0.8 + rng() * 0.4,
      seed: Math.floor(rng() * 99999),
    })
  }

  /* ─── MID-GROUND (z: -8 to -40) — Sparse silhouettes ─── */
  // Just a handful of assets — they'll appear as dark shapes in fog

  // 2 bushy corals
  for (let i = 0; i < 2; i++) {
    const side = i % 2 === 0 ? 1 : -1
    assets.push({
      type: 'bushy',
      x: side * (CENTER_CLEAR + 5 + rng() * 15),
      z: -10 - rng() * 28,
      scale: 1.2 + rng() * 0.8,
      seed: Math.floor(rng() * 99999),
    })
  }

  // 2 plate corals
  for (let i = 0; i < 2; i++) {
    const side = i % 2 === 0 ? -1 : 1
    assets.push({
      type: 'plate',
      x: side * (CENTER_CLEAR + 4 + rng() * 18),
      z: -12 - rng() * 25,
      scale: 1.0 + rng() * 0.6,
      seed: Math.floor(rng() * 99999),
    })
  }

  // 1 chippi — partially buried, distant
  assets.push({
    type: 'chippi',
    x: (rng() > 0.5 ? 1 : -1) * (CENTER_CLEAR + 3 + rng() * 10),
    z: -15 - rng() * 20,
    scale: 1.0 + rng() * 0.5,
    seed: Math.floor(rng() * 99999),
    hasPearl: false,
  })

  // 1 sangu — mid-distance, smaller
  assets.push({
    type: 'sangu',
    x: (rng() > 0.5 ? 1 : -1) * (CENTER_CLEAR + 6 + rng() * 12),
    z: -18 - rng() * 15,
    scale: 1.0 + rng() * 0.5,
    seed: Math.floor(rng() * 99999),
  })

  /* ─── FAR BACKGROUND (z: -40 to -70) — Rare shapes ─── */
  // Just 2-3 tiny pieces — fog will eat most detail

  assets.push({
    type: 'bushy',
    x: (rng() > 0.5 ? 1 : -1) * (CENTER_CLEAR + 8 + rng() * 20),
    z: -42 - rng() * 25,
    scale: 0.8 + rng() * 0.5,
    seed: Math.floor(rng() * 99999),
  })

  assets.push({
    type: 'plate',
    x: (rng() > 0.5 ? 1 : -1) * (CENTER_CLEAR + 10 + rng() * 15),
    z: -48 - rng() * 20,
    scale: 0.7 + rng() * 0.4,
    seed: Math.floor(rng() * 99999),
  })

  return assets
}


/* ─────────────── RENDER ─────────────── */

export default function MarineAssets() {
  const assets = useMemo(() => generatePlacements(), [])

  return (
    <group>
      {assets.map((a, i) => {
        const assetRng = mulberry32(a.seed)
        const pos = [a.x, FLOOR_Y, a.z]

        switch (a.type) {
          case 'chippi':
            return <Chippi key={i} position={pos} scale={a.scale} rng={assetRng} hasPearl={a.hasPearl} />
          case 'sangu':
            return <Sangu key={i} position={pos} scale={a.scale} rng={assetRng} />
          case 'bushy':
            return <BushyCoral key={i} position={pos} scale={a.scale} rng={assetRng} />
          case 'plate':
            return <PlateCoral key={i} position={pos} scale={a.scale} rng={assetRng} />
          case 'muthu':
            return <Muthu key={i} position={pos} scale={a.scale} rng={assetRng} />
          default:
            return null
        }
      })}
    </group>
  )
}
